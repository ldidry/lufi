var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});

// themes/default/public/js/lib/lufi.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj3, key, value) => key in obj3 ? __defProp(obj3, key, { enumerable: true, configurable: true, writable: true, value }) : obj3[key] = value;
var __require2 = /* @__PURE__ */ ((x2) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof __require !== "undefined" ? __require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof __require !== "undefined") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __commonJS = (cb, mod) => function __require22() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj3, key, value) => __defNormalProp(obj3, typeof key !== "symbol" ? key + "" : key, value);
var require_events = __commonJS({
  "node_modules/.deno/events@3.3.0/node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err2.context = er;
        throw err2;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i2, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i2;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err2) {
          emitter.removeListener(name, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});
var require_sjcl = __commonJS({
  "node_modules/.deno/lufi-sjcl@1.0.8/node_modules/lufi-sjcl/sjcl.js"(exports, module) {
    "use strict";
    var sjcl2 = { cipher: {}, hash: {}, keyexchange: {}, mode: {}, misc: {}, codec: {}, exception: { corrupt: function(a2) {
      this.toString = function() {
        return "CORRUPT: " + this.message;
      };
      this.message = a2;
    }, invalid: function(a2) {
      this.toString = function() {
        return "INVALID: " + this.message;
      };
      this.message = a2;
    }, bug: function(a2) {
      this.toString = function() {
        return "BUG: " + this.message;
      };
      this.message = a2;
    }, notReady: function(a2) {
      this.toString = function() {
        return "NOT READY: " + this.message;
      };
      this.message = a2;
    } } };
    sjcl2.cipher.aes = function(a2) {
      this.w[0][0][0] || this.C();
      var b2, c2, d2, e2, f2 = this.w[0][4], g2 = this.w[1];
      b2 = a2.length;
      var h2 = 1;
      if (4 !== b2 && 6 !== b2 && 8 !== b2) throw new sjcl2.exception.invalid("invalid aes key size");
      this.b = [d2 = a2.slice(0), e2 = []];
      for (a2 = b2; a2 < 4 * b2 + 28; a2++) {
        c2 = d2[a2 - 1];
        if (0 === a2 % b2 || 8 === b2 && 4 === a2 % b2) c2 = f2[c2 >>> 24] << 24 ^ f2[c2 >> 16 & 255] << 16 ^ f2[c2 >> 8 & 255] << 8 ^ f2[c2 & 255], 0 === a2 % b2 && (c2 = c2 << 8 ^ c2 >>> 24 ^ h2 << 24, h2 = h2 << 1 ^ 283 * (h2 >> 7));
        d2[a2] = d2[a2 - b2] ^ c2;
      }
      for (b2 = 0; a2; b2++, a2--) c2 = d2[b2 & 3 ? a2 : a2 - 4], e2[b2] = 4 >= a2 || 4 > b2 ? c2 : g2[0][f2[c2 >>> 24]] ^ g2[1][f2[c2 >> 16 & 255]] ^ g2[2][f2[c2 >> 8 & 255]] ^ g2[3][f2[c2 & 255]];
    };
    sjcl2.cipher.aes.prototype = { encrypt: function(a2) {
      return aa(this, a2, 0);
    }, decrypt: function(a2) {
      return aa(this, a2, 1);
    }, w: [[[], [], [], [], []], [[], [], [], [], []]], C: function() {
      var a2 = this.w[0], b2 = this.w[1], c2 = a2[4], d2 = b2[4], e2, f2, g2, h2 = [], k = [], n2, l2, m2, p2;
      for (e2 = 0; 256 > e2; e2++) k[(h2[e2] = e2 << 1 ^ 283 * (e2 >> 7)) ^ e2] = e2;
      for (f2 = g2 = 0; !c2[f2]; f2 ^= n2 || 1, g2 = k[g2] || 1) for (m2 = g2 ^ g2 << 1 ^ g2 << 2 ^ g2 << 3 ^ g2 << 4, m2 = m2 >> 8 ^ m2 & 255 ^ 99, c2[f2] = m2, d2[m2] = f2, l2 = h2[e2 = h2[n2 = h2[f2]]], p2 = 16843009 * l2 ^ 65537 * e2 ^ 257 * n2 ^ 16843008 * f2, l2 = 257 * h2[m2] ^ 16843008 * m2, e2 = 0; 4 > e2; e2++) a2[e2][f2] = l2 = l2 << 24 ^ l2 >>> 8, b2[e2][m2] = p2 = p2 << 24 ^ p2 >>> 8;
      for (e2 = 0; 5 > e2; e2++) a2[e2] = a2[e2].slice(0), b2[e2] = b2[e2].slice(0);
    } };
    function aa(a2, b2, c2) {
      if (4 !== b2.length) throw new sjcl2.exception.invalid("invalid aes block size");
      var d2 = a2.b[c2], e2 = b2[0] ^ d2[0], f2 = b2[c2 ? 3 : 1] ^ d2[1], g2 = b2[2] ^ d2[2];
      b2 = b2[c2 ? 1 : 3] ^ d2[3];
      var h2, k, n2, l2 = d2.length / 4 - 2, m2, p2 = 4, z = [0, 0, 0, 0];
      h2 = a2.w[c2];
      a2 = h2[0];
      var A = h2[1], C = h2[2], B2 = h2[3], D = h2[4];
      for (m2 = 0; m2 < l2; m2++) h2 = a2[e2 >>> 24] ^ A[f2 >> 16 & 255] ^ C[g2 >> 8 & 255] ^ B2[b2 & 255] ^ d2[p2], k = a2[f2 >>> 24] ^ A[g2 >> 16 & 255] ^ C[b2 >> 8 & 255] ^ B2[e2 & 255] ^ d2[p2 + 1], n2 = a2[g2 >>> 24] ^ A[b2 >> 16 & 255] ^ C[e2 >> 8 & 255] ^ B2[f2 & 255] ^ d2[p2 + 2], b2 = a2[b2 >>> 24] ^ A[e2 >> 16 & 255] ^ C[f2 >> 8 & 255] ^ B2[g2 & 255] ^ d2[p2 + 3], p2 += 4, e2 = h2, f2 = k, g2 = n2;
      for (m2 = 0; 4 > m2; m2++) z[c2 ? 3 & -m2 : m2] = D[e2 >>> 24] << 24 ^ D[f2 >> 16 & 255] << 16 ^ D[g2 >> 8 & 255] << 8 ^ D[b2 & 255] ^ d2[p2++], h2 = e2, e2 = f2, f2 = g2, g2 = b2, b2 = h2;
      return z;
    }
    sjcl2.bitArray = { bitSlice: function(a2, b2, c2) {
      a2 = sjcl2.bitArray.Y(a2.slice(b2 / 32), 32 - (b2 & 31)).slice(1);
      return void 0 === c2 ? a2 : sjcl2.bitArray.clamp(a2, c2 - b2);
    }, extract: function(a2, b2, c2) {
      var d2 = Math.floor(-b2 - c2 & 31);
      return ((b2 + c2 - 1 ^ b2) & -32 ? a2[b2 / 32 | 0] << 32 - d2 ^ a2[b2 / 32 + 1 | 0] >>> d2 : a2[b2 / 32 | 0] >>> d2) & (1 << c2) - 1;
    }, concat: function(a2, b2) {
      if (0 === a2.length || 0 === b2.length) return a2.concat(b2);
      var c2 = a2[a2.length - 1], d2 = sjcl2.bitArray.getPartial(c2);
      return 32 === d2 ? a2.concat(b2) : sjcl2.bitArray.Y(b2, d2, c2 | 0, a2.slice(0, a2.length - 1));
    }, bitLength: function(a2) {
      var b2 = a2.length;
      return 0 === b2 ? 0 : 32 * (b2 - 1) + sjcl2.bitArray.getPartial(a2[b2 - 1]);
    }, clamp: function(a2, b2) {
      if (32 * a2.length < b2) return a2;
      a2 = a2.slice(0, Math.ceil(b2 / 32));
      var c2 = a2.length;
      b2 = b2 & 31;
      0 < c2 && b2 && (a2[c2 - 1] = sjcl2.bitArray.partial(b2, a2[c2 - 1] & 2147483648 >> b2 - 1, 1));
      return a2;
    }, partial: function(a2, b2, c2) {
      return 32 === a2 ? b2 : (c2 ? b2 | 0 : b2 << 32 - a2) + 1099511627776 * a2;
    }, getPartial: function(a2) {
      return Math.round(a2 / 1099511627776) || 32;
    }, equal: function(a2, b2) {
      if (sjcl2.bitArray.bitLength(a2) !== sjcl2.bitArray.bitLength(b2)) return false;
      var c2 = 0, d2;
      for (d2 = 0; d2 < a2.length; d2++) c2 |= a2[d2] ^ b2[d2];
      return 0 === c2;
    }, Y: function(a2, b2, c2, d2) {
      var e2;
      e2 = 0;
      for (void 0 === d2 && (d2 = []); 32 <= b2; b2 -= 32) d2.push(c2), c2 = 0;
      if (0 === b2) return d2.concat(a2);
      for (e2 = 0; e2 < a2.length; e2++) d2.push(c2 | a2[e2] >>> b2), c2 = a2[e2] << 32 - b2;
      e2 = a2.length ? a2[a2.length - 1] : 0;
      a2 = sjcl2.bitArray.getPartial(e2);
      d2.push(sjcl2.bitArray.partial(b2 + a2 & 31, 32 < b2 + a2 ? c2 : d2.pop(), 1));
      return d2;
    }, P: function(a2, b2) {
      return [a2[0] ^ b2[0], a2[1] ^ b2[1], a2[2] ^ b2[2], a2[3] ^ b2[3]];
    }, byteswapM: function(a2) {
      var b2, c2;
      for (b2 = 0; b2 < a2.length; ++b2) c2 = a2[b2], a2[b2] = c2 >>> 24 | c2 >>> 8 & 65280 | (c2 & 65280) << 8 | c2 << 24;
      return a2;
    } };
    sjcl2.codec.utf8String = { fromBits: function(a2) {
      var b2 = "", c2 = sjcl2.bitArray.bitLength(a2), d2, e2;
      for (d2 = 0; d2 < c2 / 8; d2++) 0 === (d2 & 3) && (e2 = a2[d2 / 4]), b2 += String.fromCharCode(e2 >>> 8 >>> 8 >>> 8), e2 <<= 8;
      return decodeURIComponent(escape(b2));
    }, toBits: function(a2) {
      a2 = unescape(encodeURIComponent(a2));
      var b2 = [], c2, d2 = 0;
      for (c2 = 0; c2 < a2.length; c2++) d2 = d2 << 8 | a2.charCodeAt(c2), 3 === (c2 & 3) && (b2.push(d2), d2 = 0);
      c2 & 3 && b2.push(sjcl2.bitArray.partial(8 * (c2 & 3), d2));
      return b2;
    } };
    sjcl2.codec.hex = { fromBits: function(a2) {
      var b2 = "", c2;
      for (c2 = 0; c2 < a2.length; c2++) b2 += ((a2[c2] | 0) + 263882790666240).toString(16).substr(4);
      return b2.substr(0, sjcl2.bitArray.bitLength(a2) / 4);
    }, toBits: function(a2) {
      var b2, c2 = [], d2;
      a2 = a2.replace(/\s|0x/g, "");
      d2 = a2.length;
      a2 = a2 + "00000000";
      for (b2 = 0; b2 < a2.length; b2 += 8) c2.push(parseInt(a2.substr(b2, 8), 16) ^ 0);
      return sjcl2.bitArray.clamp(c2, 4 * d2);
    } };
    sjcl2.codec.base64 = { S: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fromBits: function(a2, b2, c2) {
      var d2 = "", e2 = 0, f2 = sjcl2.codec.base64.S, g2 = 0, h2 = sjcl2.bitArray.bitLength(a2);
      c2 && (f2 = f2.substr(0, 62) + "-_");
      for (c2 = 0; 6 * d2.length < h2; ) d2 += f2.charAt((g2 ^ a2[c2] >>> e2) >>> 26), 6 > e2 ? (g2 = a2[c2] << 6 - e2, e2 += 26, c2++) : (g2 <<= 6, e2 -= 6);
      for (; d2.length & 3 && !b2; ) d2 += "=";
      return d2;
    }, toBits: function(a2, b2) {
      a2 = a2.replace(/\s|=/g, "");
      var c2 = [], d2, e2 = 0, f2 = sjcl2.codec.base64.S, g2 = 0, h2;
      b2 && (f2 = f2.substr(0, 62) + "-_");
      for (d2 = 0; d2 < a2.length; d2++) {
        h2 = f2.indexOf(a2.charAt(d2));
        if (0 > h2) throw new sjcl2.exception.invalid("this isn't base64!");
        26 < e2 ? (e2 -= 26, c2.push(g2 ^ h2 >>> e2), g2 = h2 << 32 - e2) : (e2 += 6, g2 ^= h2 << 32 - e2);
      }
      e2 & 56 && c2.push(sjcl2.bitArray.partial(e2 & 56, g2, 1));
      return c2;
    } };
    sjcl2.codec.base64url = { fromBits: function(a2) {
      return sjcl2.codec.base64.fromBits(a2, 1, 1);
    }, toBits: function(a2) {
      return sjcl2.codec.base64.toBits(a2, 1);
    } };
    sjcl2.hash.sha256 = function(a2) {
      this.b[0] || this.C();
      a2 ? (this.g = a2.g.slice(0), this.f = a2.f.slice(0), this.c = a2.c) : this.reset();
    };
    sjcl2.hash.sha256.hash = function(a2) {
      return new sjcl2.hash.sha256().update(a2).finalize();
    };
    sjcl2.hash.sha256.prototype = { blockSize: 512, reset: function() {
      this.g = this.o.slice(0);
      this.f = [];
      this.c = 0;
      return this;
    }, update: function(a2) {
      "string" === typeof a2 && (a2 = sjcl2.codec.utf8String.toBits(a2));
      var b2, c2 = this.f = sjcl2.bitArray.concat(this.f, a2);
      b2 = this.c;
      a2 = this.c = b2 + sjcl2.bitArray.bitLength(a2);
      if (9007199254740991 < a2) throw new sjcl2.exception.invalid("Cannot hash more than 2^53 - 1 bits");
      if ("undefined" !== typeof Uint32Array) {
        var d2 = new Uint32Array(c2), e2 = 0;
        for (b2 = 512 + b2 - (512 + b2 & 511); b2 <= a2; b2 += 512) this.l(d2.subarray(
          16 * e2,
          16 * (e2 + 1)
        )), e2 += 1;
        c2.splice(0, 16 * e2);
      } else for (b2 = 512 + b2 - (512 + b2 & 511); b2 <= a2; b2 += 512) this.l(c2.splice(0, 16));
      return this;
    }, finalize: function() {
      var a2, b2 = this.f, c2 = this.g, b2 = sjcl2.bitArray.concat(b2, [sjcl2.bitArray.partial(1, 1)]);
      for (a2 = b2.length + 2; a2 & 15; a2++) b2.push(0);
      b2.push(Math.floor(this.c / 4294967296));
      for (b2.push(this.c | 0); b2.length; ) this.l(b2.splice(0, 16));
      this.reset();
      return c2;
    }, o: [], b: [], C: function() {
      function a2(a22) {
        return 4294967296 * (a22 - Math.floor(a22)) | 0;
      }
      for (var b2 = 0, c2 = 2, d2, e2; 64 > b2; c2++) {
        e2 = true;
        for (d2 = 2; d2 * d2 <= c2; d2++) if (0 === c2 % d2) {
          e2 = false;
          break;
        }
        e2 && (8 > b2 && (this.o[b2] = a2(Math.pow(c2, 0.5))), this.b[b2] = a2(Math.pow(c2, 1 / 3)), b2++);
      }
    }, l: function(a2) {
      var b2, c2, d2, e2 = this.g, f2 = this.b, g2 = e2[0], h2 = e2[1], k = e2[2], n2 = e2[3], l2 = e2[4], m2 = e2[5], p2 = e2[6], z = e2[7];
      for (b2 = 0; 64 > b2; b2++) 16 > b2 ? c2 = a2[b2] : (c2 = a2[b2 + 1 & 15], d2 = a2[b2 + 14 & 15], c2 = a2[b2 & 15] = (c2 >>> 7 ^ c2 >>> 18 ^ c2 >>> 3 ^ c2 << 25 ^ c2 << 14) + (d2 >>> 17 ^ d2 >>> 19 ^ d2 >>> 10 ^ d2 << 15 ^ d2 << 13) + a2[b2 & 15] + a2[b2 + 9 & 15] | 0), c2 = c2 + z + (l2 >>> 6 ^ l2 >>> 11 ^ l2 >>> 25 ^ l2 << 26 ^ l2 << 21 ^ l2 << 7) + (p2 ^ l2 & (m2 ^ p2)) + f2[b2], z = p2, p2 = m2, m2 = l2, l2 = n2 + c2 | 0, n2 = k, k = h2, h2 = g2, g2 = c2 + (h2 & k ^ n2 & (h2 ^ k)) + (h2 >>> 2 ^ h2 >>> 13 ^ h2 >>> 22 ^ h2 << 30 ^ h2 << 19 ^ h2 << 10) | 0;
      e2[0] = e2[0] + g2 | 0;
      e2[1] = e2[1] + h2 | 0;
      e2[2] = e2[2] + k | 0;
      e2[3] = e2[3] + n2 | 0;
      e2[4] = e2[4] + l2 | 0;
      e2[5] = e2[5] + m2 | 0;
      e2[6] = e2[6] + p2 | 0;
      e2[7] = e2[7] + z | 0;
    } };
    sjcl2.hash.sha512 = function(a2) {
      this.b[0] || this.C();
      a2 ? (this.g = a2.g.slice(0), this.f = a2.f.slice(0), this.c = a2.c) : this.reset();
    };
    sjcl2.hash.sha512.hash = function(a2) {
      return new sjcl2.hash.sha512().update(a2).finalize();
    };
    sjcl2.hash.sha512.prototype = { blockSize: 1024, reset: function() {
      this.g = this.o.slice(0);
      this.f = [];
      this.c = 0;
      return this;
    }, update: function(a2) {
      "string" === typeof a2 && (a2 = sjcl2.codec.utf8String.toBits(a2));
      var b2, c2 = this.f = sjcl2.bitArray.concat(this.f, a2);
      b2 = this.c;
      a2 = this.c = b2 + sjcl2.bitArray.bitLength(a2);
      if (9007199254740991 < a2) throw new sjcl2.exception.invalid("Cannot hash more than 2^53 - 1 bits");
      if ("undefined" !== typeof Uint32Array) {
        var d2 = new Uint32Array(c2), e2 = 0;
        for (b2 = 1024 + b2 - (1024 + b2 & 1023); b2 <= a2; b2 += 1024) this.l(d2.subarray(32 * e2, 32 * (e2 + 1))), e2 += 1;
        c2.splice(0, 32 * e2);
      } else for (b2 = 1024 + b2 - (1024 + b2 & 1023); b2 <= a2; b2 += 1024) this.l(c2.splice(0, 32));
      return this;
    }, finalize: function() {
      var a2, b2 = this.f, c2 = this.g, b2 = sjcl2.bitArray.concat(b2, [sjcl2.bitArray.partial(1, 1)]);
      for (a2 = b2.length + 4; a2 & 31; a2++) b2.push(0);
      b2.push(0);
      b2.push(0);
      b2.push(Math.floor(this.c / 4294967296));
      for (b2.push(this.c | 0); b2.length; ) this.l(b2.splice(0, 32));
      this.reset();
      return c2;
    }, o: [], ia: [12372232, 13281083, 9762859, 1914609, 15106769, 4090911, 4308331, 8266105], b: [], ka: [
      2666018,
      15689165,
      5061423,
      9034684,
      4764984,
      380953,
      1658779,
      7176472,
      197186,
      7368638,
      14987916,
      16757986,
      8096111,
      1480369,
      13046325,
      6891156,
      15813330,
      5187043,
      9229749,
      11312229,
      2818677,
      10937475,
      4324308,
      1135541,
      6741931,
      11809296,
      16458047,
      15666916,
      11046850,
      698149,
      229999,
      945776,
      13774844,
      2541862,
      12856045,
      9810911,
      11494366,
      7844520,
      15576806,
      8533307,
      15795044,
      4337665,
      16291729,
      5553712,
      15684120,
      6662416,
      7413802,
      12308920,
      13816008,
      4303699,
      9366425,
      10176680,
      13195875,
      4295371,
      6546291,
      11712675,
      15708924,
      1519456,
      15772530,
      6568428,
      6495784,
      8568297,
      13007125,
      7492395,
      2515356,
      12632583,
      14740254,
      7262584,
      1535930,
      13146278,
      16321966,
      1853211,
      294276,
      13051027,
      13221564,
      1051980,
      4080310,
      6651434,
      14088940,
      4675607
    ], C: function() {
      function a2(a22) {
        return 4294967296 * (a22 - Math.floor(a22)) | 0;
      }
      function b2(a22) {
        return 1099511627776 * (a22 - Math.floor(a22)) & 255;
      }
      for (var c2 = 0, d2 = 2, e2, f2; 80 > c2; d2++) {
        f2 = true;
        for (e2 = 2; e2 * e2 <= d2; e2++) if (0 === d2 % e2) {
          f2 = false;
          break;
        }
        f2 && (8 > c2 && (this.o[2 * c2] = a2(Math.pow(d2, 0.5)), this.o[2 * c2 + 1] = b2(Math.pow(d2, 0.5)) << 24 | this.ia[c2]), this.b[2 * c2] = a2(Math.pow(d2, 1 / 3)), this.b[2 * c2 + 1] = b2(Math.pow(d2, 1 / 3)) << 24 | this.ka[c2], c2++);
      }
    }, l: function(a2) {
      var b2, c2, d2 = this.g, e2 = this.b, f2 = d2[0], g2 = d2[1], h2 = d2[2], k = d2[3], n2 = d2[4], l2 = d2[5], m2 = d2[6], p2 = d2[7], z = d2[8], A = d2[9], C = d2[10], B2 = d2[11], D = d2[12], P = d2[13], ea = d2[14], Q = d2[15], t2;
      if ("undefined" !== typeof Uint32Array) {
        t2 = Array(160);
        for (var r2 = 0; 32 > r2; r2++) t2[r2] = a2[r2];
      } else t2 = a2;
      var r2 = f2, u2 = g2, G = h2, E2 = k, H = n2, F = l2, V = m2, I = p2, w2 = z, v = A, R = C, J = B2, S = D, K = P, W = ea, L = Q;
      for (a2 = 0; 80 > a2; a2++) {
        if (16 > a2) b2 = t2[2 * a2], c2 = t2[2 * a2 + 1];
        else {
          c2 = t2[2 * (a2 - 15)];
          var q = t2[2 * (a2 - 15) + 1];
          b2 = (q << 31 | c2 >>> 1) ^ (q << 24 | c2 >>> 8) ^ c2 >>> 7;
          var x2 = (c2 << 31 | q >>> 1) ^ (c2 << 24 | q >>> 8) ^ (c2 << 25 | q >>> 7);
          c2 = t2[2 * (a2 - 2)];
          var y2 = t2[2 * (a2 - 2) + 1], q = (y2 << 13 | c2 >>> 19) ^ (c2 << 3 | y2 >>> 29) ^ c2 >>> 6, y2 = (c2 << 13 | y2 >>> 19) ^ (y2 << 3 | c2 >>> 29) ^ (c2 << 26 | y2 >>> 6), X = t2[2 * (a2 - 7)], Y = t2[2 * (a2 - 16)], M2 = t2[2 * (a2 - 16) + 1];
          c2 = x2 + t2[2 * (a2 - 7) + 1];
          b2 = b2 + X + (c2 >>> 0 < x2 >>> 0 ? 1 : 0);
          c2 += y2;
          b2 += q + (c2 >>> 0 < y2 >>> 0 ? 1 : 0);
          c2 += M2;
          b2 += Y + (c2 >>> 0 < M2 >>> 0 ? 1 : 0);
        }
        t2[2 * a2] = b2 |= 0;
        t2[2 * a2 + 1] = c2 |= 0;
        var X = w2 & R ^ ~w2 & S, fa = v & J ^ ~v & K, y2 = r2 & G ^ r2 & H ^ G & H, ja = u2 & E2 ^ u2 & F ^ E2 & F, Y = (u2 << 4 | r2 >>> 28) ^ (r2 << 30 | u2 >>> 2) ^ (r2 << 25 | u2 >>> 7), M2 = (r2 << 4 | u2 >>> 28) ^ (u2 << 30 | r2 >>> 2) ^ (u2 << 25 | r2 >>> 7), ka = e2[2 * a2], ga = e2[2 * a2 + 1], q = L + ((w2 << 18 | v >>> 14) ^ (w2 << 14 | v >>> 18) ^ (v << 23 | w2 >>> 9)), x2 = W + ((v << 18 | w2 >>> 14) ^ (v << 14 | w2 >>> 18) ^ (w2 << 23 | v >>> 9)) + (q >>> 0 < L >>> 0 ? 1 : 0), q = q + fa, x2 = x2 + (X + (q >>> 0 < fa >>> 0 ? 1 : 0)), q = q + ga, x2 = x2 + (ka + (q >>> 0 < ga >>> 0 ? 1 : 0)), q = q + c2 | 0, x2 = x2 + (b2 + (q >>> 0 < c2 >>> 0 ? 1 : 0));
        c2 = M2 + ja;
        b2 = Y + y2 + (c2 >>> 0 < M2 >>> 0 ? 1 : 0);
        W = S;
        L = K;
        S = R;
        K = J;
        R = w2;
        J = v;
        v = I + q | 0;
        w2 = V + x2 + (v >>> 0 < I >>> 0 ? 1 : 0) | 0;
        V = H;
        I = F;
        H = G;
        F = E2;
        G = r2;
        E2 = u2;
        u2 = q + c2 | 0;
        r2 = x2 + b2 + (u2 >>> 0 < q >>> 0 ? 1 : 0) | 0;
      }
      g2 = d2[1] = g2 + u2 | 0;
      d2[0] = f2 + r2 + (g2 >>> 0 < u2 >>> 0 ? 1 : 0) | 0;
      k = d2[3] = k + E2 | 0;
      d2[2] = h2 + G + (k >>> 0 < E2 >>> 0 ? 1 : 0) | 0;
      l2 = d2[5] = l2 + F | 0;
      d2[4] = n2 + H + (l2 >>> 0 < F >>> 0 ? 1 : 0) | 0;
      p2 = d2[7] = p2 + I | 0;
      d2[6] = m2 + V + (p2 >>> 0 < I >>> 0 ? 1 : 0) | 0;
      A = d2[9] = A + v | 0;
      d2[8] = z + w2 + (A >>> 0 < v >>> 0 ? 1 : 0) | 0;
      B2 = d2[11] = B2 + J | 0;
      d2[10] = C + R + (B2 >>> 0 < J >>> 0 ? 1 : 0) | 0;
      P = d2[13] = P + K | 0;
      d2[12] = D + S + (P >>> 0 < K >>> 0 ? 1 : 0) | 0;
      Q = d2[15] = Q + L | 0;
      d2[14] = ea + W + (Q >>> 0 < L >>> 0 ? 1 : 0) | 0;
    } };
    sjcl2.mode.ccm = { name: "ccm", F: [], listenProgress: function(a2) {
      sjcl2.mode.ccm.F.push(a2);
    }, unListenProgress: function(a2) {
      a2 = sjcl2.mode.ccm.F.indexOf(a2);
      -1 < a2 && sjcl2.mode.ccm.F.splice(a2, 1);
    }, da: function(a2) {
      var b2 = sjcl2.mode.ccm.F.slice(), c2;
      for (c2 = 0; c2 < b2.length; c2 += 1) b2[c2](a2);
    }, encrypt: function(a2, b2, c2, d2, e2) {
      var f2, g2 = b2.slice(0), h2 = sjcl2.bitArray, k = h2.bitLength(c2) / 8, n2 = h2.bitLength(g2) / 8;
      e2 = e2 || 64;
      d2 = d2 || [];
      if (7 > k) throw new sjcl2.exception.invalid("ccm: iv must be at least 7 bytes");
      for (f2 = 2; 4 > f2 && n2 >>> 8 * f2; f2++) ;
      f2 < 15 - k && (f2 = 15 - k);
      c2 = h2.clamp(
        c2,
        8 * (15 - f2)
      );
      b2 = sjcl2.mode.ccm.U(a2, b2, c2, d2, e2, f2);
      g2 = sjcl2.mode.ccm.V(a2, g2, c2, b2, e2, f2);
      return h2.concat(g2.data, g2.tag);
    }, decrypt: function(a2, b2, c2, d2, e2) {
      e2 = e2 || 64;
      d2 = d2 || [];
      var f2 = sjcl2.bitArray, g2 = f2.bitLength(c2) / 8, h2 = f2.bitLength(b2), k = f2.clamp(b2, h2 - e2), n2 = f2.bitSlice(b2, h2 - e2), h2 = (h2 - e2) / 8;
      if (7 > g2) throw new sjcl2.exception.invalid("ccm: iv must be at least 7 bytes");
      for (b2 = 2; 4 > b2 && h2 >>> 8 * b2; b2++) ;
      b2 < 15 - g2 && (b2 = 15 - g2);
      c2 = f2.clamp(c2, 8 * (15 - b2));
      k = sjcl2.mode.ccm.V(a2, k, c2, n2, e2, b2);
      a2 = sjcl2.mode.ccm.U(a2, k.data, c2, d2, e2, b2);
      if (!f2.equal(k.tag, a2)) throw new sjcl2.exception.corrupt("ccm: tag doesn't match");
      return k.data;
    }, ma: function(a2, b2, c2, d2, e2, f2) {
      var g2 = [], h2 = sjcl2.bitArray, k = h2.P;
      d2 = [h2.partial(8, (b2.length ? 64 : 0) | d2 - 2 << 2 | f2 - 1)];
      d2 = h2.concat(d2, c2);
      d2[3] |= e2;
      d2 = a2.encrypt(d2);
      if (b2.length) for (c2 = h2.bitLength(b2) / 8, 65279 >= c2 ? g2 = [h2.partial(16, c2)] : 4294967295 >= c2 && (g2 = h2.concat([h2.partial(16, 65534)], [c2])), g2 = h2.concat(g2, b2), b2 = 0; b2 < g2.length; b2 += 4) d2 = a2.encrypt(k(d2, g2.slice(b2, b2 + 4).concat([0, 0, 0])));
      return d2;
    }, U: function(a2, b2, c2, d2, e2, f2) {
      var g2 = sjcl2.bitArray, h2 = g2.P;
      e2 /= 8;
      if (e2 % 2 || 4 > e2 || 16 < e2) throw new sjcl2.exception.invalid("ccm: invalid tag length");
      if (4294967295 < d2.length || 4294967295 < b2.length) throw new sjcl2.exception.bug("ccm: can't deal with 4GiB or more data");
      c2 = sjcl2.mode.ccm.ma(a2, d2, c2, e2, g2.bitLength(b2) / 8, f2);
      for (d2 = 0; d2 < b2.length; d2 += 4) c2 = a2.encrypt(h2(c2, b2.slice(d2, d2 + 4).concat([0, 0, 0])));
      return g2.clamp(c2, 8 * e2);
    }, V: function(a2, b2, c2, d2, e2, f2) {
      var g2, h2 = sjcl2.bitArray;
      g2 = h2.P;
      var k = b2.length, n2 = h2.bitLength(b2), l2 = k / 50, m2 = l2;
      c2 = h2.concat([h2.partial(8, f2 - 1)], c2).concat([0, 0, 0]).slice(0, 4);
      d2 = h2.bitSlice(g2(d2, a2.encrypt(c2)), 0, e2);
      if (!k) return { tag: d2, data: [] };
      for (g2 = 0; g2 < k; g2 += 4) g2 > l2 && (sjcl2.mode.ccm.da(g2 / k), l2 += m2), c2[3]++, e2 = a2.encrypt(c2), b2[g2] ^= e2[0], b2[g2 + 1] ^= e2[1], b2[g2 + 2] ^= e2[2], b2[g2 + 3] ^= e2[3];
      return { tag: d2, data: h2.clamp(b2, n2) };
    } };
    sjcl2.misc.hmac = function(a2, b2) {
      this.W = b2 = b2 || sjcl2.hash.sha256;
      var c2 = [[], []], d2, e2 = b2.prototype.blockSize / 32;
      this.B = [new b2(), new b2()];
      a2.length > e2 && (a2 = b2.hash(a2));
      for (d2 = 0; d2 < e2; d2++) c2[0][d2] = a2[d2] ^ 909522486, c2[1][d2] = a2[d2] ^ 1549556828;
      this.B[0].update(c2[0]);
      this.B[1].update(c2[1]);
      this.O = new b2(this.B[0]);
    };
    sjcl2.misc.hmac.prototype.encrypt = sjcl2.misc.hmac.prototype.mac = function(a2) {
      if (this.Z) throw new sjcl2.exception.invalid("encrypt on already updated hmac called!");
      this.update(a2);
      return this.digest(a2);
    };
    sjcl2.misc.hmac.prototype.reset = function() {
      this.O = new this.W(this.B[0]);
      this.Z = false;
    };
    sjcl2.misc.hmac.prototype.update = function(a2) {
      this.Z = true;
      this.O.update(a2);
    };
    sjcl2.misc.hmac.prototype.digest = function() {
      var a2 = this.O.finalize(), a2 = new this.W(this.B[1]).update(a2).finalize();
      this.reset();
      return a2;
    };
    sjcl2.misc.pbkdf2 = function(a2, b2, c2, d2, e2) {
      c2 = c2 || 1e4;
      if (0 > d2 || 0 > c2) throw new sjcl2.exception.invalid("invalid params to pbkdf2");
      "string" === typeof a2 && (a2 = sjcl2.codec.utf8String.toBits(a2));
      "string" === typeof b2 && (b2 = sjcl2.codec.utf8String.toBits(b2));
      e2 = e2 || sjcl2.misc.hmac;
      a2 = new e2(a2);
      var f2, g2, h2, k, n2 = [], l2 = sjcl2.bitArray;
      for (k = 1; 32 * n2.length < (d2 || 1); k++) {
        e2 = f2 = a2.encrypt(l2.concat(b2, [k]));
        for (g2 = 1; g2 < c2; g2++) for (f2 = a2.encrypt(f2), h2 = 0; h2 < f2.length; h2++) e2[h2] ^= f2[h2];
        n2 = n2.concat(e2);
      }
      d2 && (n2 = l2.clamp(n2, d2));
      return n2;
    };
    sjcl2.prng = function(a2) {
      this.h = [new sjcl2.hash.sha256()];
      this.s = [0];
      this.N = 0;
      this.G = {};
      this.M = 0;
      this.T = {};
      this.X = this.i = this.u = this.fa = 0;
      this.b = [0, 0, 0, 0, 0, 0, 0, 0];
      this.m = [0, 0, 0, 0];
      this.K = void 0;
      this.L = a2;
      this.D = false;
      this.J = { progress: {}, seeded: {} };
      this.A = this.ea = 0;
      this.H = 1;
      this.I = 2;
      this.aa = 65536;
      this.R = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024];
      this.ba = 3e4;
      this.$ = 80;
    };
    sjcl2.prng.prototype = {
      randomWords: function(a2, b2) {
        var c2 = [], d2;
        d2 = this.isReady(b2);
        var e2;
        if (d2 === this.A) throw new sjcl2.exception.notReady("generator isn't seeded");
        if (d2 & this.I) {
          d2 = !(d2 & this.H);
          e2 = [];
          var f2 = 0, g2;
          this.X = e2[0] = (/* @__PURE__ */ new Date()).valueOf() + this.ba;
          for (g2 = 0; 16 > g2; g2++) e2.push(4294967296 * Math.random() | 0);
          for (g2 = 0; g2 < this.h.length && (e2 = e2.concat(this.h[g2].finalize()), f2 += this.s[g2], this.s[g2] = 0, d2 || !(this.N & 1 << g2)); g2++) ;
          this.N >= 1 << this.h.length && (this.h.push(new sjcl2.hash.sha256()), this.s.push(0));
          this.i -= f2;
          f2 > this.u && (this.u = f2);
          this.N++;
          this.b = sjcl2.hash.sha256.hash(this.b.concat(e2));
          this.K = new sjcl2.cipher.aes(this.b);
          for (d2 = 0; 4 > d2 && (this.m[d2] = this.m[d2] + 1 | 0, !this.m[d2]); d2++) ;
        }
        for (d2 = 0; d2 < a2; d2 += 4) 0 === (d2 + 1) % this.aa && ba(this), e2 = N(this), c2.push(e2[0], e2[1], e2[2], e2[3]);
        ba(this);
        return c2.slice(0, a2);
      },
      setDefaultParanoia: function(a2, b2) {
        if (0 === a2 && "Setting paranoia=0 will ruin your security; use it only for testing" !== b2) throw new sjcl2.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
        this.L = a2;
      },
      addEntropy: function(a2, b2, c2) {
        c2 = c2 || "user";
        var d2, e2, f2 = (/* @__PURE__ */ new Date()).valueOf(), g2 = this.G[c2], h2 = this.isReady(), k = 0;
        d2 = this.T[c2];
        void 0 === d2 && (d2 = this.T[c2] = this.fa++);
        void 0 === g2 && (g2 = this.G[c2] = 0);
        this.G[c2] = (this.G[c2] + 1) % this.h.length;
        switch (typeof a2) {
          case "number":
            void 0 === b2 && (b2 = 1);
            this.h[g2].update([d2, this.M++, 1, b2, f2, 1, a2 | 0]);
            break;
          case "object":
            c2 = Object.prototype.toString.call(a2);
            if ("[object Uint32Array]" === c2) {
              e2 = [];
              for (c2 = 0; c2 < a2.length; c2++) e2.push(a2[c2]);
              a2 = e2;
            } else for ("[object Array]" !== c2 && (k = 1), c2 = 0; c2 < a2.length && !k; c2++) "number" !== typeof a2[c2] && (k = 1);
            if (!k) {
              if (void 0 === b2) for (c2 = b2 = 0; c2 < a2.length; c2++) for (e2 = a2[c2]; 0 < e2; ) b2++, e2 = e2 >>> 1;
              this.h[g2].update([d2, this.M++, 2, b2, f2, a2.length].concat(a2));
            }
            break;
          case "string":
            void 0 === b2 && (b2 = a2.length);
            this.h[g2].update([d2, this.M++, 3, b2, f2, a2.length]);
            this.h[g2].update(a2);
            break;
          default:
            k = 1;
        }
        if (k) throw new sjcl2.exception.bug("random: addEntropy only supports number, array of numbers or string");
        this.s[g2] += b2;
        this.i += b2;
        h2 === this.A && (this.isReady() !== this.A && ca("seeded", Math.max(this.u, this.i)), ca("progress", this.getProgress()));
      },
      isReady: function(a2) {
        a2 = this.R[void 0 !== a2 ? a2 : this.L];
        return this.u && this.u >= a2 ? this.s[0] > this.$ && (/* @__PURE__ */ new Date()).valueOf() > this.X ? this.I | this.H : this.H : this.i >= a2 ? this.I | this.A : this.A;
      },
      getProgress: function(a2) {
        a2 = this.R[a2 ? a2 : this.L];
        return this.u >= a2 ? 1 : this.i > a2 ? 1 : this.i / a2;
      },
      startCollectors: function() {
        if (!this.D) {
          this.a = { loadTimeCollector: O(this, this.la), mouseCollector: O(this, this.na), keyboardCollector: O(this, this.ja), accelerometerCollector: O(this, this.ca), touchCollector: O(this, this.pa) };
          if (window.addEventListener) window.addEventListener(
            "load",
            this.a.loadTimeCollector,
            false
          ), window.addEventListener("mousemove", this.a.mouseCollector, false), window.addEventListener("keypress", this.a.keyboardCollector, false), window.addEventListener("devicemotion", this.a.accelerometerCollector, false), window.addEventListener("touchmove", this.a.touchCollector, false);
          else if (document.attachEvent) document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector);
          else throw new sjcl2.exception.bug("can't attach event");
          this.D = true;
        }
      },
      stopCollectors: function() {
        this.D && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, false), window.removeEventListener("mousemove", this.a.mouseCollector, false), window.removeEventListener("keypress", this.a.keyboardCollector, false), window.removeEventListener("devicemotion", this.a.accelerometerCollector, false), window.removeEventListener("touchmove", this.a.touchCollector, false)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent(
          "onmousemove",
          this.a.mouseCollector
        ), document.detachEvent("keypress", this.a.keyboardCollector)), this.D = false);
      },
      addEventListener: function(a2, b2) {
        this.J[a2][this.ea++] = b2;
      },
      removeEventListener: function(a2, b2) {
        var c2, d2, e2 = this.J[a2], f2 = [];
        for (d2 in e2) e2.hasOwnProperty(d2) && e2[d2] === b2 && f2.push(d2);
        for (c2 = 0; c2 < f2.length; c2++) d2 = f2[c2], delete e2[d2];
      },
      ja: function() {
        T(this, 1);
      },
      na: function(a2) {
        var b2, c2;
        try {
          b2 = a2.x || a2.clientX || a2.offsetX || 0, c2 = a2.y || a2.clientY || a2.offsetY || 0;
        } catch (d2) {
          c2 = b2 = 0;
        }
        0 != b2 && 0 != c2 && this.addEntropy([b2, c2], 2, "mouse");
        T(this, 0);
      },
      pa: function(a2) {
        a2 = a2.touches[0] || a2.changedTouches[0];
        this.addEntropy([a2.pageX || a2.clientX, a2.pageY || a2.clientY], 1, "touch");
        T(this, 0);
      },
      la: function() {
        T(this, 2);
      },
      ca: function(a2) {
        a2 = a2.accelerationIncludingGravity.x || a2.accelerationIncludingGravity.y || a2.accelerationIncludingGravity.z;
        if (window.orientation) {
          var b2 = window.orientation;
          "number" === typeof b2 && this.addEntropy(b2, 1, "accelerometer");
        }
        a2 && this.addEntropy(a2, 2, "accelerometer");
        T(this, 0);
      }
    };
    function ca(a2, b2) {
      var c2, d2 = sjcl2.random.J[a2], e2 = [];
      for (c2 in d2) d2.hasOwnProperty(c2) && e2.push(d2[c2]);
      for (c2 = 0; c2 < e2.length; c2++) e2[c2](b2);
    }
    function T(a2, b2) {
      "undefined" !== typeof window && window.performance && "function" === typeof window.performance.now ? a2.addEntropy(window.performance.now(), b2, "loadtime") : a2.addEntropy((/* @__PURE__ */ new Date()).valueOf(), b2, "loadtime");
    }
    function ba(a2) {
      a2.b = N(a2).concat(N(a2));
      a2.K = new sjcl2.cipher.aes(a2.b);
    }
    function N(a2) {
      for (var b2 = 0; 4 > b2 && (a2.m[b2] = a2.m[b2] + 1 | 0, !a2.m[b2]); b2++) ;
      return a2.K.encrypt(a2.m);
    }
    function O(a2, b2) {
      return function() {
        b2.apply(a2, arguments);
      };
    }
    sjcl2.random = new sjcl2.prng(6);
    a: try {
      if (ha = "undefined" !== typeof module && module.exports) {
        try {
          ia = __require2("crypto");
        } catch (a2) {
          ia = null;
        }
        ha = da = ia;
      }
      if (ha && da.randomBytes) U = da.randomBytes(128), U = new Uint32Array(new Uint8Array(U).buffer), sjcl2.random.addEntropy(U, 1024, "crypto['randomBytes']");
      else if ("undefined" !== typeof window && "undefined" !== typeof Uint32Array) {
        Z = new Uint32Array(32);
        if (window.crypto && window.crypto.getRandomValues) window.crypto.getRandomValues(Z);
        else if (window.msCrypto && window.msCrypto.getRandomValues) window.msCrypto.getRandomValues(Z);
        else break a;
        sjcl2.random.addEntropy(Z, 1024, "crypto['getRandomValues']");
      }
    } catch (a2) {
      "undefined" !== typeof window && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(a2));
    }
    var U;
    var da;
    var Z;
    var ha;
    var ia;
    sjcl2.json = { defaults: { v: 1, iter: 1e4, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes" }, ha: function(a2, b2, c2, d2) {
      c2 = c2 || {};
      d2 = d2 || {};
      var e2 = sjcl2.json, f2 = e2.j({ iv: sjcl2.random.randomWords(4, 0) }, e2.defaults), g2;
      e2.j(f2, c2);
      c2 = f2.adata;
      "string" === typeof f2.salt && (f2.salt = sjcl2.codec.base64.toBits(f2.salt));
      "string" === typeof f2.iv && (f2.iv = sjcl2.codec.base64.toBits(f2.iv));
      if (!sjcl2.mode[f2.mode] || !sjcl2.cipher[f2.cipher] || "string" === typeof a2 && 100 >= f2.iter || 64 !== f2.ts && 96 !== f2.ts && 128 !== f2.ts || 128 !== f2.ks && 192 !== f2.ks && 256 !== f2.ks || 2 > f2.iv.length || 4 < f2.iv.length) throw new sjcl2.exception.invalid("json encrypt: invalid parameters");
      "string" === typeof a2 ? (g2 = sjcl2.misc.cachedPbkdf2(a2, f2), a2 = g2.key.slice(0, f2.ks / 32), f2.salt = g2.salt) : sjcl2.ecc && a2 instanceof sjcl2.ecc.elGamal.publicKey && (g2 = a2.kem(), f2.kemtag = g2.tag, a2 = g2.key.slice(0, f2.ks / 32));
      "string" === typeof b2 && (b2 = sjcl2.codec.utf8String.toBits(b2));
      "string" === typeof c2 && (f2.adata = c2 = sjcl2.codec.utf8String.toBits(c2));
      g2 = new sjcl2.cipher[f2.cipher](a2);
      e2.j(d2, f2);
      d2.key = a2;
      f2.ct = "ccm" === f2.mode && sjcl2.arrayBuffer && sjcl2.arrayBuffer.ccm && b2 instanceof ArrayBuffer ? sjcl2.arrayBuffer.ccm.encrypt(g2, b2, f2.iv, c2, f2.ts) : sjcl2.mode[f2.mode].encrypt(g2, b2, f2.iv, c2, f2.ts);
      return f2;
    }, encrypt: function(a2, b2, c2, d2) {
      var e2 = sjcl2.json, f2 = e2.ha.apply(e2, arguments);
      return e2.encode(f2);
    }, ga: function(a2, b2, c2, d2) {
      c2 = c2 || {};
      d2 = d2 || {};
      var e2 = sjcl2.json;
      b2 = e2.j(e2.j(e2.j({}, e2.defaults), b2), c2, true);
      var f2, g2;
      f2 = b2.adata;
      "string" === typeof b2.salt && (b2.salt = sjcl2.codec.base64.toBits(b2.salt));
      "string" === typeof b2.iv && (b2.iv = sjcl2.codec.base64.toBits(b2.iv));
      if (!sjcl2.mode[b2.mode] || !sjcl2.cipher[b2.cipher] || "string" === typeof a2 && 100 >= b2.iter || 64 !== b2.ts && 96 !== b2.ts && 128 !== b2.ts || 128 !== b2.ks && 192 !== b2.ks && 256 !== b2.ks || !b2.iv || 2 > b2.iv.length || 4 < b2.iv.length) throw new sjcl2.exception.invalid("json decrypt: invalid parameters");
      "string" === typeof a2 ? (g2 = sjcl2.misc.cachedPbkdf2(a2, b2), a2 = g2.key.slice(0, b2.ks / 32), b2.salt = g2.salt) : sjcl2.ecc && a2 instanceof sjcl2.ecc.elGamal.secretKey && (a2 = a2.unkem(sjcl2.codec.base64.toBits(b2.kemtag)).slice(0, b2.ks / 32));
      "string" === typeof f2 && (f2 = sjcl2.codec.utf8String.toBits(f2));
      g2 = new sjcl2.cipher[b2.cipher](a2);
      f2 = "ccm" === b2.mode && sjcl2.arrayBuffer && sjcl2.arrayBuffer.ccm && b2.ct instanceof ArrayBuffer ? sjcl2.arrayBuffer.ccm.decrypt(g2, b2.ct, b2.iv, b2.tag, f2, b2.ts) : sjcl2.mode[b2.mode].decrypt(g2, b2.ct, b2.iv, f2, b2.ts);
      e2.j(d2, b2);
      d2.key = a2;
      return 1 === c2.raw ? f2 : sjcl2.codec.utf8String.fromBits(f2);
    }, decrypt: function(a2, b2, c2, d2) {
      var e2 = sjcl2.json;
      return e2.ga(a2, e2.decode(b2), c2, d2);
    }, encode: function(a2) {
      var b2, c2 = "{", d2 = "";
      for (b2 in a2) if (a2.hasOwnProperty(b2)) {
        if (!b2.match(/^[a-z0-9]+$/i)) throw new sjcl2.exception.invalid("json encode: invalid property name");
        c2 += d2 + '"' + b2 + '":';
        d2 = ",";
        switch (typeof a2[b2]) {
          case "number":
          case "boolean":
            c2 += a2[b2];
            break;
          case "string":
            c2 += '"' + escape(a2[b2]) + '"';
            break;
          case "object":
            c2 += '"' + sjcl2.codec.base64.fromBits(a2[b2], 0) + '"';
            break;
          default:
            throw new sjcl2.exception.bug("json encode: unsupported type");
        }
      }
      return c2 + "}";
    }, decode: function(a2) {
      a2 = a2.replace(/\s/g, "");
      if (!a2.match(/^\{.*\}$/)) throw new sjcl2.exception.invalid("json decode: this isn't json!");
      a2 = a2.replace(/^\{|\}$/g, "").split(/,/);
      var b2 = {}, c2, d2;
      for (c2 = 0; c2 < a2.length; c2++) {
        if (!(d2 = a2[c2].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) throw new sjcl2.exception.invalid("json decode: this isn't json!");
        null != d2[3] ? b2[d2[2]] = parseInt(d2[3], 10) : null != d2[4] ? b2[d2[2]] = d2[2].match(/^(ct|adata|salt|iv)$/) ? sjcl2.codec.base64.toBits(d2[4]) : unescape(d2[4]) : null != d2[5] && (b2[d2[2]] = "true" === d2[5]);
      }
      return b2;
    }, j: function(a2, b2, c2) {
      void 0 === a2 && (a2 = {});
      if (void 0 === b2) return a2;
      for (var d2 in b2) if (b2.hasOwnProperty(d2)) {
        if (c2 && void 0 !== a2[d2] && a2[d2] !== b2[d2]) throw new sjcl2.exception.invalid("required parameter overridden");
        a2[d2] = b2[d2];
      }
      return a2;
    }, ra: function(a2, b2) {
      var c2 = {}, d2;
      for (d2 in a2) a2.hasOwnProperty(d2) && a2[d2] !== b2[d2] && (c2[d2] = a2[d2]);
      return c2;
    }, qa: function(a2, b2) {
      var c2 = {}, d2;
      for (d2 = 0; d2 < b2.length; d2++) void 0 !== a2[b2[d2]] && (c2[b2[d2]] = a2[b2[d2]]);
      return c2;
    } };
    sjcl2.encrypt = sjcl2.json.encrypt;
    sjcl2.decrypt = sjcl2.json.decrypt;
    sjcl2.misc.oa = {};
    sjcl2.misc.cachedPbkdf2 = function(a2, b2) {
      var c2 = sjcl2.misc.oa, d2;
      b2 = b2 || {};
      d2 = b2.iter || 1e3;
      c2 = c2[a2] = c2[a2] || {};
      d2 = c2[d2] = c2[d2] || { firstSalt: b2.salt && b2.salt.length ? b2.salt.slice(0) : sjcl2.random.randomWords(2, 0) };
      c2 = void 0 === b2.salt ? d2.firstSalt : b2.salt;
      d2[c2] = d2[c2] || sjcl2.misc.pbkdf2(a2, c2, b2.iter);
      return { key: d2[c2].slice(0), salt: c2.slice(0) };
    };
    "undefined" !== typeof module && module.exports && (module.exports = sjcl2);
    "function" === typeof define && define([], function() {
      return sjcl2;
    });
  }
});
var lufi_exports = {};
__export(lufi_exports, {
  addFilesToArchive: () => addFilesToArchive,
  cancel: () => cancel,
  compress: () => compress,
  decompress: () => decompress,
  download: () => download,
  events: () => events,
  getFileIndexInQueue: () => getFileIndexInQueue,
  infos: () => infos,
  pause: () => pause,
  remove: () => remove,
  resume: () => resume,
  upload: () => upload
});
var import_events2 = __toESM(require_events());
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v) {
      return Promise.resolve(v).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v) {
        return new Promise(function(a2, b2) {
          q.push([n2, v, a2, b2]) > 1 || resume2(n2, v);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume2(n2, v) {
    try {
      step(g2[n2](v));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle(f2, v) {
    if (f2(v), q.shift(), q.length) resume2(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v) {
      return (p2 = !p2) ? { value: __await(o2[n2](v)), done: false } : f2 ? f2(v) : v;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o2[n2](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
}
var ResultAsync = class _ResultAsync {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new _ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e2) => new Err(errorFn(e2)));
    return new _ResultAsync(newPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromThrowable(fn, errorFn) {
    return (...args) => {
      return new _ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
        try {
          return new Ok(yield fn(...args));
        } catch (error) {
          return new Err(errorFn ? errorFn(error) : error);
        }
      }))());
    };
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f2(res.value));
    })));
  }
  andThrough(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newRes = yield f2(res.value);
      if (newRes.isErr()) {
        return new Err(newRes.error);
      }
      return new Ok(res.value);
    })));
  }
  andTee(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      try {
        yield f2(res.value);
      } catch (e2) {
      }
      return new Ok(res.value);
    })));
  }
  mapErr(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f2(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return new _ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f2(res.value);
      return newValue instanceof _ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f2(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t2) {
    return this._promise.then((res) => res.unwrapOr(t2));
  }
  /**
   * @deprecated will be removed in 9.0.0.
   *
   * You can use `safeTry` without this method.
   * @example
   * ```typescript
   * safeTry(async function* () {
   *   const okValue = yield* yourResult
   * })
   * ```
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a() {
      const result = yield __await(this._promise);
      if (result.isErr()) {
        yield yield __await(errAsync(result.error));
      }
      return yield __await(result.value);
    });
  }
};
var okAsync = (value) => new ResultAsync(Promise.resolve(new Ok(value)));
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var fromAsyncThrowable = ResultAsync.fromThrowable;
var combineResultList = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr()) {
      acc = err(result.error);
      break;
    } else {
      acc.map((list) => list.push(result.value));
    }
  }
  return acc;
};
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr() && acc.isErr()) {
      acc.error.push(result.error);
    } else if (result.isErr() && acc.isOk()) {
      acc = err([result.error]);
    } else if (result.isOk() && acc.isOk()) {
      acc.value.push(result.value);
    }
  }
  return acc;
};
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e2) {
        return err(errorFn ? errorFn(e2) : e2);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
function err(err2) {
  return new Err(err2);
}
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f2) {
    return ok(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThrough(f2) {
    return f2(this.value).map((_value) => this.value);
  }
  andTee(f2) {
    try {
      f2(this.value);
    } catch (e2) {
    }
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f2) {
    return f2(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  asyncAndThrough(f2) {
    return f2(this.value).map(() => this.value);
  }
  asyncMap(f2) {
    return ResultAsync.fromSafePromise(f2(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return function* () {
      return value;
    }();
  }
  _unsafeUnwrap(_) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
  // eslint-disable-next-line @typescript-eslint/no-this-alias, require-yield
  *[Symbol.iterator]() {
    return this.value;
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f2) {
    return err(f2(this.error));
  }
  andThrough(_f) {
    return err(this.error);
  }
  andTee(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f2) {
    return f2(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  asyncAndThrough(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v) {
    return v;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_) {
    return this.error;
  }
  *[Symbol.iterator]() {
    const self = this;
    yield self;
    return self;
  }
};
var fromThrowable = Result.fromThrowable;
var LufiFile = class _LufiFile {
  constructor(serverUrl, properties) {
    __publicField(this, "actionToken", "");
    __publicField(this, "chunksReady", 0);
    __publicField(this, "createdAt", 0);
    __publicField(this, "delay", 0);
    __publicField(this, "delAtFirstView", false);
    __publicField(this, "keys", { client: "", server: "" });
    __publicField(this, "name", "");
    __publicField(this, "password", "");
    __publicField(this, "queueIndex", 0);
    __publicField(this, "serverUrl");
    __publicField(this, "size", 0);
    __publicField(
      this,
      "uploadStatus",
      3
      /* INITIALIZED */
    );
    __publicField(this, "totalChunks", 0);
    __publicField(this, "type", "");
    __publicField(this, "zipped", false);
    this.serverUrl = serverUrl;
    Object.assign(this, properties);
  }
  downloadUrl() {
    const serverUrl = new URL(this.serverUrl);
    return new URL(
      `${serverUrl.origin + serverUrl.pathname}r/${this.keys.server}#${this.keys.client}`
    );
  }
  removeUrl() {
    const serverUrl = new URL(this.serverUrl);
    return new URL(
      `${serverUrl.origin + serverUrl.pathname}d/${this.keys.server}/${this.actionToken}`
    );
  }
  static fromDownloadUrl(downloadUrl, password = "") {
    const pathinfos = downloadUrl.pathname.split("r/");
    const keys = {
      client: downloadUrl.hash.slice(1).split("&")[0],
      server: pathinfos[1]
    };
    return new _LufiFile(downloadUrl.origin + pathinfos[0], {
      keys,
      password
    });
  }
  static fromRemoveUrl(removeUrl, password = "") {
    const pathInfos = removeUrl.pathname.split("d/");
    const splittedPath = pathInfos[1].split("/");
    const keys = { client: "", server: splittedPath[0] };
    return new _LufiFile(removeUrl.origin + pathInfos[0], {
      keys,
      password,
      actionToken: splittedPath[1]
    });
  }
};
var import_events = __toESM(require_events());
var BaseError = class extends Error {
  constructor(message, options = {}) {
    const { cause, context } = options;
    super(message, { cause });
    __publicField(this, "context");
    this.name = this.constructor.name;
    this.context = context;
  }
};
var ConnectionError = class extends BaseError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "Unable to connect. Is the computer able to access the url?");
  }
};
var ServerError = class extends BaseError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "The server returned an error");
  }
};
var ensureError = (value) => {
  if (value instanceof Error) return value;
  let stringified = "[Unable to stringify the thrown value]";
  try {
    stringified = JSON.stringify(value);
  } catch (_error) {
  }
  return new Error(stringified);
};
var fetchServerConfig = (instanceUrl) => {
  const originMatches = instanceUrl.href.match(
    /(.*?)\/?(?:\/[dr]{1}\/|login\/?|files\/?)/
  );
  const urlOrigin = originMatches && originMatches[1] ? originMatches[1] : instanceUrl.origin;
  return ResultAsync.fromPromise(
    fetch(urlOrigin + "/about/config"),
    (error) => new ConnectionError(void 0, {
      cause: ensureError(error)
    })
  ).andThen((response) => {
    if (response.ok) {
      return ResultAsync.fromPromise(
        response.json(),
        (error) => ensureError(error)
      );
    } else {
      return errAsync(
        new ServerError(void 0, { context: response.statusText })
      );
    }
  });
};
var isDenoRuntime = () => typeof Deno !== "undefined";
var isSecureContext2 = () => {
  return isDenoRuntime() || globalThis.isSecureContext || globalThis.location.protocol === "https:";
};
var workerUrl = (relativePath) => {
  return isDenoRuntime() ? new URL(`./worker/${relativePath}.ts`, new URL(".", import.meta.url).href) : new URL(
    import.meta.resolve(
      `./${relativePath !== "encrypt" ? `worker/${relativePath}` : relativePath}.js`
    )
  );
};
var LufiJob = class {
  constructor(lufiFile, workerType) {
    __publicField(this, "events", new import_events.default());
    __publicField(this, "lufiFile");
    __publicField(
      this,
      "status",
      2
      /* ONGOING */
    );
    __publicField(this, "archiveFile");
    __publicField(this, "archiveFiles", []);
    __publicField(this, "downloadedFile");
    __publicField(this, "worker");
    __publicField(this, "isTerminated", false);
    __publicField(this, "complete", () => {
      this.status = 0;
      this.events.emit(
        "JOB_TERMINATED"
        /* JOB_TERMINATED */
      );
    });
    __publicField(
      this,
      "hasFailed",
      () => this.status === 1
      /* FAILED */
    );
    __publicField(this, "onError", (callback) => {
      this.worker.onerror = (event) => {
        callback(event);
      };
      return this;
    });
    __publicField(this, "onMessage", (callback) => {
      this.worker.onmessage = (e2) => {
        if (callback) {
          callback(e2);
        }
        const event = e2.data.event;
        if (event) {
          if (event === "FILE_UPDATED") {
            Object.assign(this.lufiFile, e2.data.lufiFile);
          } else {
            this.dispatchEvent(event, e2.data.error);
          }
        }
      };
      return this;
    });
    __publicField(this, "onMessageError", (callback) => {
      this.worker.onmessageerror = (event) => {
        callback(event);
      };
      return this;
    });
    __publicField(this, "onProgress", (callback) => {
      this.events.on("CHUNK_UPLOADED", () => {
        callback();
      });
      this.events.on("CHUNK_DOWNLOADED", () => {
        callback();
      });
      return this;
    });
    __publicField(this, "requestMessage", (msg, transferable = []) => {
      this.worker.postMessage(msg, transferable);
      return this;
    });
    __publicField(this, "terminate", () => {
      this.worker.terminate();
      return this;
    });
    __publicField(this, "waitForCompletion", () => {
      if (this.isTerminated) {
        if (this.status === 0) {
          return okAsync(this);
        } else {
          return errAsync(ensureError("Job has failed"));
        }
      } else {
        return ResultAsync.fromPromise(
          new Promise((resolve, reject) => {
            this.events.once("OPERATION_FAILED", (error) => {
              reject(error);
            });
            this.events.once("JOB_TERMINATED", () => {
              if (this.status === 0) {
                resolve(this);
              }
            });
          }),
          (error) => ensureError(error)
        );
      }
    });
    __publicField(this, "waitForStart", () => ResultAsync.fromPromise(
      new Promise((resolve, reject) => {
        this.events.once("OPERATION_FAILED", (error) => {
          reject(error);
        });
        this.events.once("UPLOAD_STARTED", () => {
          resolve(this);
        });
        this.events.once("DOWNLOAD_STARTED", () => {
          resolve(this);
        });
      }),
      (error) => ensureError(error)
    ));
    __publicField(this, "dispatchEvent", (event, error) => {
      this.events.emit(event, error);
    });
    switch (workerType) {
      case 0:
        {
          this.worker = new Worker(workerUrl("cancel"), { type: "module" });
        }
        break;
      case 1:
        {
          this.worker = new Worker(workerUrl("compress"), { type: "module" });
        }
        break;
      case 2:
        {
          this.worker = new Worker(workerUrl("decompress"), { type: "module" });
        }
        break;
      case 3:
        {
          this.worker = new Worker(workerUrl("download"), { type: "module" });
        }
        break;
      case 4:
        {
          this.worker = new Worker(workerUrl("infos"), { type: "module" });
        }
        break;
      case 5:
        {
          this.worker = new Worker(workerUrl("remove"), { type: "module" });
        }
        break;
      case 6:
        {
          this.worker = new Worker(workerUrl("upload"), { type: "module" });
        }
        break;
    }
    this.lufiFile = lufiFile;
    this.events.once("JOB_TERMINATED", () => {
      this.isTerminated = true;
      this.terminate();
    });
    this.events.once("OPERATION_FAILED", (error) => {
      this.status = 1;
      this.lufiFile.uploadStatus = 2;
      this.events.emit("JOB_TERMINATED", error);
    });
    this.onError((event) => console.error(event.error));
  }
};
var Encoding = class {
  /**
   *
   * @param charset Charset to use for base64 encoding. This must be 64-characters long.
   * @param noPadding If true, encoded strings won't include padding.
   */
  constructor(charset, noPadding) {
    if (!charset || charset.length != 64) {
      throw Error("Charset must contain 64 characters");
    }
    this._charset = charset;
    this._noPadding = !!noPadding;
    this._valid = new RegExp("^[" + this._charset.replace("-", "\\-") + "]+={0,2}$");
  }
  /**
   * Encode an ArrayBuffer to base64 in a string.
   * @param ab Data to encode to base64
   * @returns Base64-encoded string
   */
  Encode(ab) {
    const len = ab.byteLength;
    if (!len) {
      return "";
    }
    const view = new Uint8Array(ab);
    let res = "";
    for (let i2 = 0; i2 < len; i2 += 3) {
      res += this._charset[view[i2] >> 2] + this._charset[(view[i2] & 3) << 4 | view[i2 + 1] >> 4] + this._charset[(view[i2 + 1] & 15) << 2 | view[i2 + 2] >> 6] + this._charset[view[i2 + 2] & 63];
    }
    if (len % 3 == 2) {
      res = res.substring(0, res.length - 1);
      if (!this._noPadding) {
        res += "=";
      }
    } else if (len % 3 == 1) {
      res = res.substring(0, res.length - 2);
      if (!this._noPadding) {
        res += "==";
      }
    }
    return res;
  }
  /**
   * Decode a string from base64. Padding is always optional.
   * @param str Base64-encoded string
   * @returns Data decoded from the base64 string
   */
  Decode(str) {
    str = (str || "").replace(/[\s]/g, "");
    if (!str) {
      return new ArrayBuffer(0);
    }
    if (!this._valid.test(str)) {
      throw Error("Invalid base64 input sequence");
    }
    let viewLen = Math.floor(str.length * 0.75);
    if (str[str.length - 2] == "=") {
      viewLen -= 2;
    } else if (str[str.length - 1] == "=") {
      viewLen--;
    }
    const view = new Uint8Array(viewLen);
    let enc1, enc2, enc3, enc4, i2 = 0, j = 0;
    while (i2 < str.length * 0.75) {
      enc1 = this._charset.indexOf(str.charAt(j++));
      enc2 = this._charset.indexOf(str.charAt(j++));
      enc3 = this._charset.indexOf(str.charAt(j++));
      enc4 = this._charset.indexOf(str.charAt(j++));
      view[i2++] = enc1 << 2 | enc2 >> 4;
      view[i2++] = (enc2 & 15) << 4 | enc3 >> 2;
      view[i2++] = (enc3 & 3) << 6 | enc4;
    }
    return view.buffer;
  }
};
var obj = new Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var obj2 = new Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", true);
function Encode(ab) {
  return obj2.Encode(ab);
}
var import_lufi_sjcl = __toESM(require_sjcl());
var CryptoError = class extends BaseError {
};
var HashingError = class extends CryptoError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "Unable to hash the provided string");
  }
};
var generateKey = () => {
  try {
    return okAsync(import_lufi_sjcl.default.codec.base64.fromBits(import_lufi_sjcl.default.random.randomWords(8, 10)));
  } catch (error) {
    return errAsync(
      new CryptoError("Unable to generate key", {
        cause: ensureError(error)
      })
    );
  }
};
var hashPassword = (password) => {
  try {
    return okAsync(import_lufi_sjcl.default.codec.hex.fromBits(import_lufi_sjcl.default.hash.sha512.hash(password)));
  } catch (error) {
    return errAsync(new HashingError(void 0, { cause: ensureError(error) }));
  }
};
var generateKey2 = () => {
  return ResultAsync.fromPromise(
    new Promise(
      (resolve, reject) => crypto.subtle.generateKey(
        {
          name: "AES-GCM",
          length: 256
        },
        true,
        ["encrypt", "decrypt"]
      ).then(
        (generatedKey) => crypto.subtle.exportKey("raw", generatedKey).then((key) => resolve(Encode(key))).catch((error) => {
          reject(
            new CryptoError("Unable to base64 encode the url", {
              cause: ensureError(error)
            })
          );
        })
      ).catch((error) => reject(error))
    ),
    (error) => new CryptoError("Unable to generate key", { cause: ensureError(error) })
  );
};
var hashPassword2 = (password) => {
  const promise = async () => {
    return Array.from(
      new Uint8Array(
        await crypto.subtle.digest(
          "SHA-512",
          new TextEncoder().encode(password)
        )
      )
    ).map((b2) => b2.toString(16).padStart(2, "0")).join("");
  };
  return ResultAsync.fromPromise(
    promise(),
    (error) => new HashingError(void 0, { cause: ensureError(error) })
  );
};
var generateKey3 = (algo = 1) => algo === 0 ? generateKey() : generateKey2();
var hashPassword3 = (password, algo) => algo === 0 ? hashPassword(password) : hashPassword2(password);
var DownloadError = class extends BaseError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "An error occured while downloading the data");
  }
};
var InfosError = class extends BaseError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "An error occured while trying to retrieve server informations");
  }
};
var JobError = class extends BaseError {
};
var JobPauseError = class extends JobError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "An error occured while trying to pause the job");
  }
};
var JobResumeError = class extends JobError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "An error occured while trying to resume the job");
  }
};
var UploadError = class extends BaseError {
  constructor() {
    super(...arguments);
    __publicField(this, "message", "An error occured while uploading the data");
  }
};
var CHUNK_LENGTH = 15e5;
var files = {};
var events = new import_events2.default();
var cancel = (uploadJob) => {
  uploadJob.terminate();
  const job = new LufiJob(
    uploadJob.lufiFile,
    0
    /* CANCEL */
  );
  return ResultAsync.fromPromise(
    new Promise((resolve, reject) => {
      job.onMessage((event) => {
        if (event.data.event === "UPLOAD_CANCELLED") {
          files[job.lufiFile.keys.client].uploadStatus = 0;
          resolve(job);
        }
        if (event.data.event === "OPERATION_FAILED") {
          reject(
            new JobError(
              "An error occured while trying to cancel an upload",
              { cause: event.data.error }
            )
          );
        }
      }).requestMessage({
        args: {
          lufiFile: job.lufiFile
        }
      });
    }),
    (error) => ensureError(error)
  );
};
var addFilesToArchive = (files2, archiveEntries = {}) => {
  const asyncLoop = async (files3) => {
    var _a;
    for (const file of files3) {
      const nameWithExtension = ((_a = file.name.split("/")) == null ? void 0 : _a.pop()) || file.name;
      const nameWithoutExtension = nameWithExtension.split(".").shift();
      const extension = nameWithExtension.split(".").length > 1 ? `.${nameWithExtension.split(".").pop()}` : "";
      let name = nameWithExtension;
      if (archiveEntries[name] !== void 0) {
        let i2 = 1;
        do {
          name = `${nameWithoutExtension}(${i2})${extension}`;
          i2++;
        } while (archiveEntries[name] !== void 0);
      }
      events.emit("ARCHIVE_ADDED_FILE", { name, size: file.size });
      archiveEntries[name] = await file.bytes();
    }
  };
  return ResultAsync.fromPromise(
    asyncLoop(files2),
    (error) => ensureError(error)
  ).andThen(() => okAsync(archiveEntries));
};
var compress = (archiveEntries, archiveName) => {
  const lufiFile = new LufiFile("");
  const job = new LufiJob(
    lufiFile,
    1
    /* COMPRESS */
  );
  return okAsync(
    job.onMessage((event) => {
      if (event.data.event === "ARCHIVE_CREATED") {
        job.archiveFile = new File([event.data.buffer], archiveName, {
          type: "application/zip"
        });
        job.complete();
      }
    }).requestMessage({
      args: {
        lufiFile,
        archive: { entries: archiveEntries }
      }
    })
  );
};
var decompress = (zipFile) => {
  const lufiFile = new LufiFile("");
  const job = new LufiJob(
    lufiFile,
    2
    /* DECOMPRESS */
  );
  return okAsync(
    job.onMessage((event) => {
      if (event.data.event === "ARCHIVE_DECOMPRESSED") {
        job.complete();
      }
      if (event.data.event === "ARCHIVE_RETRIEVED_FILE") {
        job.archiveFiles.push(
          new File([event.data.file.buffer], event.data.file.path)
        );
      }
    }).requestMessage({
      args: {
        lufiFile,
        archive: { file: zipFile }
      }
    })
  );
};
var handlePasswordHashing = (downloadUrl, password) => {
  if (password) {
    return fetchServerConfig(downloadUrl).andThen((config) => {
      if (config.version.tag > "0.07.0") {
        const algo = isSecureContext2() ? 1 : 0;
        return hashPassword3(password, algo).andThen(
          (hashedPassword) => okAsync(LufiFile.fromDownloadUrl(downloadUrl, hashedPassword))
        );
      } else {
        return okAsync(LufiFile.fromDownloadUrl(downloadUrl, password));
      }
    });
  } else {
    return okAsync(LufiFile.fromDownloadUrl(downloadUrl));
  }
};
var download = (downloadUrl, password) => handlePasswordHashing(downloadUrl, password).andThen(
  (lufiFile) => {
    const job = new LufiJob(
      lufiFile,
      3
      /* DOWNLOAD */
    );
    return ResultAsync.fromPromise(
      new Promise((resolve, reject) => {
        const chunks = [];
        return job.onMessage((event) => {
          handleSocketResults(resolve, reject, job, event);
          if (event.data.event === "CHUNK_DOWNLOADED") {
            chunks.push(event.data.chunk.buffer);
            if (chunks.length >= 50) {
              job.downloadedFile = new File(
                job.downloadedFile ? [job.downloadedFile.slice()].concat(chunks) : chunks,
                lufiFile.name,
                {
                  type: lufiFile.type
                }
              );
              chunks.length = 0;
            }
          }
          if (event.data.event === "DOWNLOAD_COMPLETE") {
            job.downloadedFile = new File(
              job.downloadedFile ? [job.downloadedFile.slice()].concat(chunks) : chunks,
              lufiFile.name,
              {
                type: lufiFile.type
              }
            );
            chunks.length = 0;
            job.complete();
          }
        }).requestMessage({
          args: {
            lufiFile
          }
        });
      }),
      (error) => new DownloadError(void 0, { cause: ensureError(error) })
    );
  }
);
var infos = (downloadUrl, password) => handlePasswordHashing(downloadUrl, password).andThen(
  (lufiFile) => okAsync(new LufiJob(
    lufiFile,
    4
    /* INFOS */
  ))
).andThen(
  (job) => ResultAsync.fromPromise(
    new Promise((resolve, reject) => {
      job.onMessage((event) => {
        if (event.data.event === "INFOS_RETRIEVED") {
          job.complete();
          resolve(job);
        }
        if (event.data.event === "OPERATION_FAILED") {
          reject(
            new JobError(
              "An error occured while trying to retrieve informations of the file",
              { cause: event.data.error }
            )
          );
        }
      }).requestMessage({
        args: { lufiFile: job.lufiFile }
      });
    }),
    (error) => new InfosError(void 0, { cause: ensureError(error) })
  )
);
var pause = (job) => {
  try {
    job.status = 3;
    return okAsync(
      job.requestMessage({
        action: 0,
        args: { lufiFile: job.lufiFile }
      })
    );
  } catch (error) {
    return errAsync(
      new JobPauseError(void 0, { cause: ensureError(error) })
    );
  }
};
var remove = (removeUrl, password) => {
  const lufiFile = LufiFile.fromRemoveUrl(removeUrl, password);
  const job = new LufiJob(
    lufiFile,
    5
    /* REMOVE */
  );
  return ResultAsync.fromPromise(
    new Promise((resolve, reject) => {
      job.onMessage((event) => {
        if (event.data.event === "FILE_REMOVED") {
          job.complete();
          resolve(job);
        }
        if (event.data.event === "OPERATION_FAILED") {
          reject(
            new JobError("An error occured while trying to remove a file", {
              cause: event.data.error
            })
          );
        }
      }).requestMessage({ args: { lufiFile } });
    }),
    (error) => ensureError(error)
  );
};
var resume = (job) => {
  try {
    job.status = 2;
    return okAsync(
      job.requestMessage({
        action: 2,
        args: { lufiFile: job.lufiFile }
      })
    );
  } catch (error) {
    return errAsync(
      new JobResumeError(void 0, { cause: ensureError(error) })
    );
  }
};
var sliceAndUpload = (job, file, algo, chunkLength = CHUNK_LENGTH) => {
  events.emit("SLICE_STARTED", files[job.lufiFile.keys.client]);
  const totalChunks = Math.ceil(file.size / chunkLength) || 1;
  const concurrency = navigator.hardwareConcurrency || 1;
  files[job.lufiFile.keys.client].totalChunks = totalChunks;
  const sequentialLoop = async () => {
    for (let i2 = 0; i2 < totalChunks; i2++) {
      const start = i2 * chunkLength;
      const end = Math.min(start + chunkLength, file.size);
      const buffer = await file.slice(start, end, file.type).arrayBuffer();
      job.requestMessage(
        {
          args: {
            chunk: {
              buffer,
              index: i2
            },
            lufiFile: files[job.lufiFile.keys.client],
            algo
          }
        },
        [buffer]
      );
      if (i2 === 0) {
        const waitUntilUploadStarted = () => new Promise((resolve) => {
          job.events.once("UPLOAD_STARTED", () => {
            resolve(void 0);
          });
        });
        await waitUntilUploadStarted();
      } else if (i2 % concurrency === 0) {
        const waitForQueueAvailability = () => new Promise((resolve) => {
          job.events.once("CHUNK_UPLOADED", () => {
            resolve(void 0);
          });
        });
        await waitForQueueAvailability();
      }
    }
  };
  sequentialLoop();
  return okAsync(void 0);
};
var startUpload = (serverUrl, file, delay, delAtFirstView, zipped, password, algo) => generateKey3(
  algo
).andThen(
  (clientKey) => {
    if (password) {
      return hashPassword3(password, algo).andThen(
        (hashedPassword) => okAsync({ password: hashedPassword, clientKey })
      );
    } else {
      return okAsync({ password, clientKey });
    }
  }
).andThen(({ password: password2, clientKey }) => {
  files[clientKey] = new LufiFile(serverUrl.toString(), {
    delay,
    delAtFirstView,
    zipped,
    password: password2,
    name: file.name.split("/").pop(),
    // Remove path from filename
    size: file.size,
    type: file.type,
    keys: { client: clientKey, server: "" }
  });
  const job = new LufiJob(
    files[clientKey],
    6
    /* UPLOAD */
  );
  files[clientKey].uploadStatus = 4;
  return sliceAndUpload(job, file, algo).andThen(
    () => ResultAsync.fromPromise(
      new Promise((resolve, reject) => {
        job.onMessage((event) => {
          handleSocketResults(resolve, reject, job, event);
          switch (event.data.event) {
            case "UPLOAD_COMPLETE":
              {
                job.complete();
                job.lufiFile.uploadStatus = 1;
              }
              break;
          }
        });
      }),
      (error) => ensureError(error)
    )
  );
});
var upload = (serverUrl, filesToUpload, delay = 0, delAtFirstView = false, zipped = false, zipName = "documents.zip", password = "", algo = 1) => {
  const operations = [];
  if (!zipped) {
    filesToUpload.forEach((file) => {
      operations.push(startUpload(
        serverUrl,
        file,
        delay,
        delAtFirstView,
        zipped,
        password,
        algo
      ));
    });
  } else {
    if (filesToUpload.length === 1 && filesToUpload[0].type === "application/zip") {
      operations.push(
        startUpload(
          serverUrl,
          filesToUpload[0],
          delay,
          delAtFirstView,
          zipped,
          password,
          algo
        )
      );
    } else {
      operations.push(
        addFilesToArchive(filesToUpload).andThen(
          (archiveEntries) => compress(
            archiveEntries,
            zipName
          ).andThen((job) => job.waitForCompletion()).andThen((job) => {
            if (job.archiveFile) {
              return startUpload(
                serverUrl,
                job.archiveFile,
                delay,
                delAtFirstView,
                true,
                password,
                algo
              );
            } else {
              return errAsync(new JobError("archiveFile must be defined"));
            }
          })
        )
      );
    }
  }
  return ResultAsync.combine(operations).orElse(
    (error) => errAsync(new UploadError(void 0, { cause: error }))
  );
};
var handleSocketResults = (resolve, reject, job, event) => {
  if (event.data.event === "SOCKET_OPENED") {
    resolve(job);
  }
  if (event.data.event === "OPERATION_FAILED") {
    reject(
      new JobError("The job returned an error", { cause: event.data.error })
    );
  }
};
var getFilesQueued = () => Object.values(files).filter(
  (file) => file.uploadStatus === 4
  /* QUEUED */
);
var getFileIndexInQueue = (clientKey) => Object.keys(getFilesQueued()).indexOf(clientKey);

// themes/default/public/js/lib/filesize.esm.min.js
var t = "array";
var i = "bit";
var o = "bits";
var e = "byte";
var n = "bytes";
var r = "";
var a = "exponent";
var b = "function";
var s = "iec";
var l = "Invalid number";
var p = "Invalid rounding method";
var u = "jedec";
var c = "object";
var d = ".";
var f = "round";
var g = "s";
var m = "si";
var B = "kbit";
var y = "kB";
var h = " ";
var M = "string";
var x = "0";
var w = { symbol: { iec: { bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"], bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"] }, jedec: { bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"], bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] } }, fullform: { iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"], jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"] } };
function E(E2, { bits: T = false, pad: j = false, base: N = -1, round: P = 2, locale: S = r, localeOptions: k = {}, separator: G = r, spacer: K = h, symbols: Y = {}, standard: Z = r, output: v = M, fullform: O = false, fullforms: $ = [], exponent: z = -1, roundingMethod: I = f, precision: L = 0 } = {}) {
  let D = z, q = Number(E2), A = [], C = 0, F = r;
  Z === m ? (N = 10, Z = u) : Z === s || Z === u ? N = 2 : 2 === N ? Z = s : (N = 10, Z = u);
  const H = 10 === N ? 1e3 : 1024, J = true === O, Q = q < 0, R = Math[I];
  if ("bigint" != typeof E2 && isNaN(E2)) throw new TypeError(l);
  if (typeof R !== b) throw new TypeError(p);
  if (Q && (q = -q), (-1 === D || isNaN(D)) && (D = Math.floor(Math.log(q) / Math.log(H)), D < 0 && (D = 0)), D > 8 && (L > 0 && (L += 8 - D), D = 8), v === a) return D;
  if (0 === q) A[0] = 0, F = A[1] = w.symbol[Z][T ? o : n][D];
  else {
    C = q / (2 === N ? Math.pow(2, 10 * D) : Math.pow(1e3, D)), T && (C *= 8, C >= H && D < 8 && (C /= H, D++));
    const t2 = Math.pow(10, D > 0 ? P : 0);
    A[0] = R(C * t2) / t2, A[0] === H && D < 8 && -1 === z && (A[0] = 1, D++), F = A[1] = 10 === N && 1 === D ? T ? B : y : w.symbol[Z][T ? o : n][D];
  }
  if (Q && (A[0] = -A[0]), L > 0 && (A[0] = A[0].toPrecision(L)), A[1] = Y[A[1]] || A[1], true === S ? A[0] = A[0].toLocaleString() : S.length > 0 ? A[0] = A[0].toLocaleString(S, k) : G.length > 0 && (A[0] = A[0].toString().replace(d, G)), j && P > 0) {
    const t2 = A[0].toString(), i2 = G || (t2.match(/(\D)/g) || []).pop() || d, o2 = t2.toString().split(i2), e2 = o2[1] || r, n2 = e2.length, a2 = P - n2;
    A[0] = `${o2[0]}${i2}${e2.padEnd(n2 + a2, x)}`;
  }
  return J && (A[1] = $[D] ? $[D] : w.fullform[Z][D] + (T ? i : e) + (1 === A[0] ? r : g)), v === t ? A : v === c ? { value: A[0], symbol: A[1], exponent: D, unit: F } : A.join(K);
}

// themes/default/public/js/lib/utils.js
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escapeHtml = (string) => String(string).replace(/[&<>"'\/]/g, (s2) => entityMap[s2]);
var notify = (title, body) => {
  if (isSecureContext) {
    if (!("Notification" in window) || typeof Notification === "undefined") {
      console.log(
        `This browser does not support desktop notification, cannot send following message: ${title} ${body}`
      );
      return;
    }
    if (Notification.permission !== "granted") {
      Notification.requestPermission();
    } else {
      new Notification(title, {
        body,
        icon: "/img/lufi.svg"
      });
    }
  }
};

// themes/default/public/js/download.js
document.addEventListener("DOMContentLoaded", () => {
  const passwordFormDOM = document.getElementById("password-form");
  const updateDOM = (type) => {
    const blockDOM = document.querySelector(`template#block-download-${type}`).content.cloneNode(true).children[0];
    blockDOM.querySelector(".size").innerText = E(
      blockDOM.querySelector(".size").dataset.filesize
    );
    if (blockDOM.querySelector(".description").dataset.isZipped === "true") {
      blockDOM.querySelector(".icon").classList.replace("fa-file", "fa-file-zipper");
    }
    document.getElementById("download-container").replaceChildren(blockDOM);
    if (type === "success") {
      document.getElementById("download-button").focus();
    }
    return blockDOM;
  };
  const isPasswordNeeded = () => passwordFormDOM !== null;
  const onPasswordEvents = () => {
    passwordFormDOM.onsubmit = (event) => {
      event.preventDefault();
      passwordFormDOM.classList.add("is-hidden");
      startDownload();
    };
  };
  const showZipContent = (zipFile) => {
    const zipContainerDOM = document.getElementById("zip-container");
    const showZipButtonDOM = document.getElementById("show-zip-button");
    zipContainerDOM.classList.remove("is-hidden");
    showZipButtonDOM.href = window.location;
    showZipButtonDOM.onclick = () => {
      const zipContentDOM = zipContainerDOM.querySelector(".content");
      document.body.style.cursor = "wait";
      showZipButtonDOM.style.cursor = "wait";
      lufi_exports.decompress(zipFile).andThen((job) => job.waitForCompletion()).map((job) => {
        zipContentDOM.replaceChildren();
        zipContentDOM.classList.remove("has-text-centered");
        job.archiveFiles.forEach((file) => {
          const itemDOM = document.querySelector("template#card-zipped-item").content.cloneNode(true).children[0];
          itemDOM.querySelector(".name").innerText = escapeHtml(file.name);
          itemDOM.querySelector(".size").innerText = E(file.size);
          const downloadItemDOM = itemDOM.querySelector(".action-download");
          downloadItemDOM.download = escapeHtml(file.name);
          downloadItemDOM.href = URL.createObjectURL(file);
          zipContentDOM.append(itemDOM);
        });
        document.body.style.cursor = "auto";
      }).mapErr((error) => {
        console.error(error);
      });
    };
  };
  const startDownload = () => {
    var _a;
    lufi_exports.download(window.location, (_a = document.getElementById("password")) == null ? void 0 : _a.value).andThen((job) => {
      const blockDOM = updateDOM("ongoing");
      warnOnReload();
      job.onProgress(() => {
        const percent = Math.round(
          job.lufiFile.chunksReady * 100 / job.lufiFile.totalChunks
        );
        blockDOM.querySelector(".progress").value = percent;
        blockDOM.querySelector(".progress").innerText = percent;
        blockDOM.querySelector(".progress-text").innerText = percent + "%";
      });
      document.getElementById("abort-button").onclick = () => {
        job.terminate();
        warnOnReload(false);
        updateDOM("aborted");
        document.getElementById("reload-button").onclick = (event) => {
          event.preventDefault();
          window.location.reload();
        };
      };
      return job.waitForCompletion();
    }).mapErr((error) => {
      updateDOM("error").querySelector(".message-body").innerText = error.message;
      warnOnReload(false);
    }).andThen((job) => {
      notify(i18n.fileDownloaded, job.lufiFile.name);
      const downloadDOM = updateDOM("success");
      const downloadButtonDOM = document.getElementById("download-button");
      const blobURL = URL.createObjectURL(job.downloadedFile);
      downloadButtonDOM.href = blobURL;
      downloadButtonDOM.download = escapeHtml(job.lufiFile.name);
      const isZipped = downloadDOM.querySelector(".description").dataset.isZipped === "true";
      let content;
      if (job.lufiFile.type.match(/^image\//) !== null) {
        content = `<img alt="${escapeHtml(
          job.lufiFile.name
        )}" src="${blobURL}">`;
      } else if (job.lufiFile.type.match(/^video\//) !== null) {
        content = `<video controls><source src="${blobURL}" type="${job.lufiFile.type}"></video>`;
      } else if (job.lufiFile.type.match(/^audio\//) !== null) {
        content = `<audio controls><source src="${blobURL}" type="${job.lufiFile.type}"></audio>`;
      }
      if (content) {
        downloadDOM.querySelector(".content").innerHTML = content;
      }
      if (isZipped) {
        showZipContent(job.downloadedFile);
      }
    });
  };
  const warnOnReload = (toWarn = true) => {
    window.onbeforeunload = toWarn ? i18n.confirmExit : null;
  };
  if (isPasswordNeeded()) {
    onPasswordEvents();
  } else {
    startDownload();
  }
});
/*!
 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 10.1.6
*/
